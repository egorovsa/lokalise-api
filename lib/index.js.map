{"version":3,"sources":["webpack://LokaliseCo/webpack/universalModuleDefinition","webpack://LokaliseCo/webpack/bootstrap","webpack://LokaliseCo/./node_modules/extract-zip/index.js","webpack://LokaliseCo/./node_modules/fd-slicer/index.js","webpack://LokaliseCo/./node_modules/pend/index.js","webpack://LokaliseCo/./node_modules/yauzl/index.js","webpack://LokaliseCo/./src/ts/api/languages.ts","webpack://LokaliseCo/./src/ts/api/projects.ts","webpack://LokaliseCo/./src/ts/api/strings.ts","webpack://LokaliseCo/./src/ts/index.ts","webpack://LokaliseCo/./src/ts/services/request.ts","webpack://LokaliseCo/external \"concat-stream\"","webpack://LokaliseCo/external \"debug\"","webpack://LokaliseCo/external \"events\"","webpack://LokaliseCo/external \"fs\"","webpack://LokaliseCo/external \"https\"","webpack://LokaliseCo/external \"mkdirp\"","webpack://LokaliseCo/external \"os\"","webpack://LokaliseCo/external \"path\"","webpack://LokaliseCo/external \"request\"","webpack://LokaliseCo/external \"stream\"","webpack://LokaliseCo/external \"superagent\"","webpack://LokaliseCo/external \"util\"","webpack://LokaliseCo/external \"zlib\""],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;AAEA;AACA;;;AAGA;AACA;;;;;;;;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,KAAK;AACL,GAAG;;AAEH;AACA;;AAEA,yBAAyB,kBAAkB;AAC3C;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,mDAAmD,qBAAqB;AACxE;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT,OAAO;;AAEP;AACA;AACA,8DAA8D,qBAAqB;AACnF;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA,mCAAmC,6DAA6D;;AAEhG;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,yBAAyB,aAAa;AACtC;AACA;AACA,4CAA4C,WAAW;AACvD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa;;AAEb;AACA;;AAEA;AACA,4DAA4D,eAAe;AAC3E;;AAEA;AACA;AACA,eAAe;;AAEf;AACA,sCAAsC,WAAW;AACjD;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,eAAe;AACf;AACA,WAAW;AACX,SAAS;AACT;AACA,KAAK;AACL;AACA;;;;;;;;;;;;AC5MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACpRA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA,sDAAsD,QAAQ;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,8BAA8B;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,uCAAuC;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAwB;AACxB,oCAAoC;AACpC,uCAAuC;;AAEvC;AACA,iCAAiC;AACjC,gCAAgC;AAChC,+BAA+B;;AAE/B;AACA;;AAEA;AACA;AACA;AACA,oCAAoC,+BAA+B,EAAE;AACrE;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;A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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"LokaliseCo\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"LokaliseCo\"] = factory();\n\telse\n\t\troot[\"LokaliseCo\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded and loading wasm modules\n \tvar installedWasmModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// object with all compiled WebAssembly.Modules\n \t__webpack_require__.w = {};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/ts/index.ts\");\n","var fs = require('fs')\nvar path = require('path')\nvar yauzl = require('yauzl')\nvar mkdirp = require('mkdirp')\nvar concat = require('concat-stream')\nvar debug = require('debug')('extract-zip')\n\nmodule.exports = function (zipPath, opts, cb) {\n  debug('creating target directory', opts.dir)\n\n  if (path.isAbsolute(opts.dir) === false) {\n    return cb(new Error('Target directory is expected to be absolute'))\n  }\n\n  mkdirp(opts.dir, function (err) {\n    if (err) return cb(err)\n\n    fs.realpath(opts.dir, function (err, canonicalDir) {\n      if (err) return cb(err)\n\n      opts.dir = canonicalDir\n\n      openZip(opts)\n    })\n  })\n\n  function openZip () {\n    debug('opening', zipPath, 'with opts', opts)\n\n    yauzl.open(zipPath, {lazyEntries: true}, function (err, zipfile) {\n      if (err) return cb(err)\n\n      var cancelled = false\n\n      zipfile.readEntry()\n\n      zipfile.on('close', function () {\n        if (!cancelled) {\n          debug('zip extraction complete')\n          cb()\n        }\n      })\n\n      zipfile.on('entry', function (entry) {\n        if (cancelled) {\n          debug('skipping entry', entry.fileName, {cancelled: cancelled})\n          return\n        }\n\n        debug('zipfile entry', entry.fileName)\n\n        if (/^__MACOSX\\//.test(entry.fileName)) {\n          // dir name starts with __MACOSX/\n          zipfile.readEntry()\n          return\n        }\n\n        var destDir = path.dirname(path.join(opts.dir, entry.fileName))\n\n        mkdirp(destDir, function (err) {\n          if (err) {\n            cancelled = true\n            zipfile.close()\n            return cb(err)\n          }\n\n          fs.realpath(destDir, function (err, canonicalDestDir) {\n            if (err) {\n              cancelled = true\n              zipfile.close()\n              return cb(err)\n            }\n\n            var relativeDestDir = path.relative(opts.dir, canonicalDestDir)\n\n            if (relativeDestDir.split(path.sep).indexOf('..') !== -1) {\n              cancelled = true\n              zipfile.close()\n              return cb(new Error('Out of bound path \"' + canonicalDestDir + '\" found while processing file ' + entry.fileName))\n            }\n\n            extractEntry(entry, function (err) {\n              // if any extraction fails then abort everything\n              if (err) {\n                cancelled = true\n                zipfile.close()\n                return cb(err)\n              }\n              debug('finished processing', entry.fileName)\n              zipfile.readEntry()\n            })\n          })\n        })\n      })\n\n      function extractEntry (entry, done) {\n        if (cancelled) {\n          debug('skipping entry extraction', entry.fileName, {cancelled: cancelled})\n          return setImmediate(done)\n        }\n\n        if (opts.onEntry) {\n          opts.onEntry(entry, zipfile)\n        }\n\n        var dest = path.join(opts.dir, entry.fileName)\n\n        // convert external file attr int into a fs stat mode int\n        var mode = (entry.externalFileAttributes >> 16) & 0xFFFF\n        // check if it's a symlink or dir (using stat mode constants)\n        var IFMT = 61440\n        var IFDIR = 16384\n        var IFLNK = 40960\n        var symlink = (mode & IFMT) === IFLNK\n        var isDir = (mode & IFMT) === IFDIR\n\n        // Failsafe, borrowed from jsZip\n        if (!isDir && entry.fileName.slice(-1) === '/') {\n          isDir = true\n        }\n\n        // check for windows weird way of specifying a directory\n        // https://github.com/maxogden/extract-zip/issues/13#issuecomment-154494566\n        var madeBy = entry.versionMadeBy >> 8\n        if (!isDir) isDir = (madeBy === 0 && entry.externalFileAttributes === 16)\n\n        // if no mode then default to default modes\n        if (mode === 0) {\n          if (isDir) {\n            if (opts.defaultDirMode) mode = parseInt(opts.defaultDirMode, 10)\n            if (!mode) mode = 493 // Default to 0755\n          } else {\n            if (opts.defaultFileMode) mode = parseInt(opts.defaultFileMode, 10)\n            if (!mode) mode = 420 // Default to 0644\n          }\n        }\n\n        debug('extracting entry', { filename: entry.fileName, isDir: isDir, isSymlink: symlink })\n\n        // reverse umask first (~)\n        var umask = ~process.umask()\n        // & with processes umask to override invalid perms\n        var procMode = mode & umask\n\n        // always ensure folders are created\n        var destDir = dest\n        if (!isDir) destDir = path.dirname(dest)\n\n        debug('mkdirp', {dir: destDir})\n        mkdirp(destDir, function (err) {\n          if (err) {\n            debug('mkdirp error', destDir, {error: err})\n            cancelled = true\n            return done(err)\n          }\n\n          if (isDir) return done()\n\n          debug('opening read stream', dest)\n          zipfile.openReadStream(entry, function (err, readStream) {\n            if (err) {\n              debug('openReadStream error', err)\n              cancelled = true\n              return done(err)\n            }\n\n            readStream.on('error', function (err) {\n              console.log('read err', err)\n            })\n\n            if (symlink) writeSymlink()\n            else writeStream()\n\n            function writeStream () {\n              var writeStream = fs.createWriteStream(dest, {mode: procMode})\n              readStream.pipe(writeStream)\n\n              writeStream.on('finish', function () {\n                done()\n              })\n\n              writeStream.on('error', function (err) {\n                debug('write error', {error: err})\n                cancelled = true\n                return done(err)\n              })\n            }\n\n            // AFAICT the content of the symlink file itself is the symlink target filename string\n            function writeSymlink () {\n              readStream.pipe(concat(function (data) {\n                var link = data.toString()\n                debug('creating symlink', link, dest)\n                fs.symlink(link, dest, function (err) {\n                  if (err) cancelled = true\n                  done(err)\n                })\n              }))\n            }\n          })\n        })\n      }\n    })\n  }\n}\n","var fs = require('fs');\nvar util = require('util');\nvar stream = require('stream');\nvar Readable = stream.Readable;\nvar Writable = stream.Writable;\nvar PassThrough = stream.PassThrough;\nvar Pend = require('pend');\nvar EventEmitter = require('events').EventEmitter;\n\nexports.createFromBuffer = createFromBuffer;\nexports.createFromFd = createFromFd;\nexports.BufferSlicer = BufferSlicer;\nexports.FdSlicer = FdSlicer;\n\nutil.inherits(FdSlicer, EventEmitter);\nfunction FdSlicer(fd, options) {\n  options = options || {};\n  EventEmitter.call(this);\n\n  this.fd = fd;\n  this.pend = new Pend();\n  this.pend.max = 1;\n  this.refCount = 0;\n  this.autoClose = !!options.autoClose;\n}\n\nFdSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.read(self.fd, buffer, offset, length, position, function(err, bytesRead, buffer) {\n      cb();\n      callback(err, bytesRead, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  var self = this;\n  self.pend.go(function(cb) {\n    fs.write(self.fd, buffer, offset, length, position, function(err, written, buffer) {\n      cb();\n      callback(err, written, buffer);\n    });\n  });\n};\n\nFdSlicer.prototype.createReadStream = function(options) {\n  return new ReadStream(this, options);\n};\n\nFdSlicer.prototype.createWriteStream = function(options) {\n  return new WriteStream(this, options);\n};\n\nFdSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nFdSlicer.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  if (self.autoClose) {\n    fs.close(self.fd, onCloseDone);\n  }\n\n  function onCloseDone(err) {\n    if (err) {\n      self.emit('error', err);\n    } else {\n      self.emit('close');\n    }\n  }\n};\n\nutil.inherits(ReadStream, Readable);\nfunction ReadStream(context, options) {\n  options = options || {};\n  Readable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = options.end;\n  this.pos = this.start;\n  this.destroyed = false;\n}\n\nReadStream.prototype._read = function(n) {\n  var self = this;\n  if (self.destroyed) return;\n\n  var toRead = Math.min(self._readableState.highWaterMark, n);\n  if (self.endOffset != null) {\n    toRead = Math.min(toRead, self.endOffset - self.pos);\n  }\n  if (toRead <= 0) {\n    self.destroyed = true;\n    self.push(null);\n    self.context.unref();\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    var buffer = new Buffer(toRead);\n    fs.read(self.context.fd, buffer, 0, toRead, self.pos, function(err, bytesRead) {\n      if (err) {\n        self.destroy(err);\n      } else if (bytesRead === 0) {\n        self.destroyed = true;\n        self.push(null);\n        self.context.unref();\n      } else {\n        self.pos += bytesRead;\n        self.push(buffer.slice(0, bytesRead));\n      }\n      cb();\n    });\n  });\n};\n\nReadStream.prototype.destroy = function(err) {\n  if (this.destroyed) return;\n  err = err || new Error(\"stream destroyed\");\n  this.destroyed = true;\n  this.emit('error', err);\n  this.context.unref();\n};\n\nutil.inherits(WriteStream, Writable);\nfunction WriteStream(context, options) {\n  options = options || {};\n  Writable.call(this, options);\n\n  this.context = context;\n  this.context.ref();\n\n  this.start = options.start || 0;\n  this.endOffset = (options.end == null) ? Infinity : +options.end;\n  this.bytesWritten = 0;\n  this.pos = this.start;\n  this.destroyed = false;\n\n  this.on('finish', this.destroy.bind(this));\n}\n\nWriteStream.prototype._write = function(buffer, encoding, callback) {\n  var self = this;\n  if (self.destroyed) return;\n\n  if (self.pos + buffer.length > self.endOffset) {\n    var err = new Error(\"maximum file length exceeded\");\n    err.code = 'ETOOBIG';\n    self.destroy();\n    callback(err);\n    return;\n  }\n  self.context.pend.go(function(cb) {\n    if (self.destroyed) return cb();\n    fs.write(self.context.fd, buffer, 0, buffer.length, self.pos, function(err, bytes) {\n      if (err) {\n        self.destroy();\n        cb();\n        callback(err);\n      } else {\n        self.bytesWritten += bytes;\n        self.pos += bytes;\n        self.emit('progress');\n        cb();\n        callback();\n      }\n    });\n  });\n};\n\nWriteStream.prototype.destroy = function() {\n  if (this.destroyed) return;\n  this.destroyed = true;\n  this.context.unref();\n};\n\nutil.inherits(BufferSlicer, EventEmitter);\nfunction BufferSlicer(buffer) {\n  EventEmitter.call(this);\n\n  this.refCount = 0;\n  this.buffer = buffer;\n}\n\nBufferSlicer.prototype.read = function(buffer, offset, length, position, callback) {\n  var end = position + length;\n  var delta = end - this.buffer.length;\n  var written = (delta > 0) ? delta : length;\n  this.buffer.copy(buffer, offset, position, end);\n  setImmediate(function() {\n    callback(null, written);\n  });\n};\n\nBufferSlicer.prototype.write = function(buffer, offset, length, position, callback) {\n  buffer.copy(this.buffer, position, offset, offset + length);\n  setImmediate(function() {\n    callback(null, length, buffer);\n  });\n};\n\nBufferSlicer.prototype.createReadStream = function(options) {\n  options = options || {};\n  var readStream = new PassThrough(options);\n  readStream.start = options.start || 0;\n  readStream.endOffset = options.end;\n  readStream.pos = readStream.endOffset || this.buffer.length; // yep, we're already done\n  readStream.destroyed = false;\n  readStream.write(this.buffer.slice(readStream.start, readStream.pos));\n  readStream.end();\n  readStream.destroy = function() {\n    readStream.destroyed = true;\n  };\n  return readStream;\n};\n\nBufferSlicer.prototype.createWriteStream = function(options) {\n  var bufferSlicer = this;\n  options = options || {};\n  var writeStream = new Writable(options);\n  writeStream.start = options.start || 0;\n  writeStream.endOffset = (options.end == null) ? this.buffer.length : +options.end;\n  writeStream.bytesWritten = 0;\n  writeStream.pos = writeStream.start;\n  writeStream.destroyed = false;\n  writeStream._write = function(buffer, encoding, callback) {\n    if (writeStream.destroyed) return;\n\n    var end = writeStream.pos + buffer.length;\n    if (end > writeStream.endOffset) {\n      var err = new Error(\"maximum file length exceeded\");\n      err.code = 'ETOOBIG';\n      writeStream.destroyed = true;\n      callback(err);\n      return;\n    }\n    buffer.copy(bufferSlicer.buffer, writeStream.pos, 0, buffer.length);\n\n    writeStream.bytesWritten += buffer.length;\n    writeStream.pos = end;\n    writeStream.emit('progress');\n    callback();\n  };\n  writeStream.destroy = function() {\n    writeStream.destroyed = true;\n  };\n  return writeStream;\n};\n\nBufferSlicer.prototype.ref = function() {\n  this.refCount += 1;\n};\n\nBufferSlicer.prototype.unref = function() {\n  this.refCount -= 1;\n\n  if (this.refCount < 0) {\n    throw new Error(\"invalid unref\");\n  }\n};\n\nfunction createFromBuffer(buffer) {\n  return new BufferSlicer(buffer);\n}\n\nfunction createFromFd(fd, options) {\n  return new FdSlicer(fd, options);\n}\n","module.exports = Pend;\n\nfunction Pend() {\n  this.pending = 0;\n  this.max = Infinity;\n  this.listeners = [];\n  this.waiting = [];\n  this.error = null;\n}\n\nPend.prototype.go = function(fn) {\n  if (this.pending < this.max) {\n    pendGo(this, fn);\n  } else {\n    this.waiting.push(fn);\n  }\n};\n\nPend.prototype.wait = function(cb) {\n  if (this.pending === 0) {\n    cb(this.error);\n  } else {\n    this.listeners.push(cb);\n  }\n};\n\nPend.prototype.hold = function() {\n  return pendHold(this);\n};\n\nfunction pendHold(self) {\n  self.pending += 1;\n  var called = false;\n  return onCb;\n  function onCb(err) {\n    if (called) throw new Error(\"callback called twice\");\n    called = true;\n    self.error = self.error || err;\n    self.pending -= 1;\n    if (self.waiting.length > 0 && self.pending < self.max) {\n      pendGo(self, self.waiting.shift());\n    } else if (self.pending === 0) {\n      var listeners = self.listeners;\n      self.listeners = [];\n      listeners.forEach(cbListener);\n    }\n  }\n  function cbListener(listener) {\n    listener(self.error);\n  }\n}\n\nfunction pendGo(self, fn) {\n  fn(pendHold(self));\n}\n","var fs = require(\"fs\");\nvar zlib = require(\"zlib\");\nvar fd_slicer = require(\"fd-slicer\");\nvar util = require(\"util\");\nvar EventEmitter = require(\"events\").EventEmitter;\nvar Transform = require(\"stream\").Transform;\nvar PassThrough = require(\"stream\").PassThrough;\nvar Writable = require(\"stream\").Writable;\n\nexports.open = open;\nexports.fromFd = fromFd;\nexports.fromBuffer = fromBuffer;\nexports.fromRandomAccessReader = fromRandomAccessReader;\nexports.dosDateTimeToDate = dosDateTimeToDate;\nexports.ZipFile = ZipFile;\nexports.Entry = Entry;\nexports.RandomAccessReader = RandomAccessReader;\n\nfunction open(path, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (callback == null) callback = defaultCallback;\n  fs.open(path, \"r\", function(err, fd) {\n    if (err) return callback(err);\n    fromFd(fd, options, function(err, zipfile) {\n      if (err) fs.close(fd, defaultCallback);\n      callback(err, zipfile);\n    });\n  });\n}\n\nfunction fromFd(fd, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (callback == null) callback = defaultCallback;\n  fs.fstat(fd, function(err, stats) {\n    if (err) return callback(err);\n    var reader = fd_slicer.createFromFd(fd, {autoClose: true});\n    fromRandomAccessReader(reader, stats.size, options, callback);\n  });\n}\n\nfunction fromBuffer(buffer, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  options.autoClose = false;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  // i got your open file right here.\n  var reader = fd_slicer.createFromBuffer(buffer);\n  fromRandomAccessReader(reader, buffer.length, options, callback);\n}\n\nfunction fromRandomAccessReader(reader, totalSize, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = null;\n  }\n  if (options == null) options = {};\n  if (options.autoClose == null) options.autoClose = true;\n  if (options.lazyEntries == null) options.lazyEntries = false;\n  if (callback == null) callback = defaultCallback;\n  if (typeof totalSize !== \"number\") throw new Error(\"expected totalSize parameter to be a number\");\n  if (totalSize > Number.MAX_SAFE_INTEGER) {\n    throw new Error(\"zip file too large. only file sizes up to 2^52 are supported due to JavaScript's Number type being an IEEE 754 double.\");\n  }\n\n  // the matching unref() call is in zipfile.close()\n  reader.ref();\n\n  // eocdr means End of Central Directory Record.\n  // search backwards for the eocdr signature.\n  // the last field of the eocdr is a variable-length comment.\n  // the comment size is encoded in a 2-byte field in the eocdr, which we can't find without trudging backwards through the comment to find it.\n  // as a consequence of this design decision, it's possible to have ambiguous zip file metadata if a coherent eocdr was in the comment.\n  // we search backwards for a eocdr signature, and hope that whoever made the zip file was smart enough to forbid the eocdr signature in the comment.\n  var eocdrWithoutCommentSize = 22;\n  var maxCommentSize = 0x10000; // 2-byte size\n  var bufferSize = Math.min(eocdrWithoutCommentSize + maxCommentSize, totalSize);\n  var buffer = new Buffer(bufferSize);\n  var bufferReadStart = totalSize - buffer.length;\n  readAndAssertNoEof(reader, buffer, 0, bufferSize, bufferReadStart, function(err) {\n    if (err) return callback(err);\n    for (var i = bufferSize - eocdrWithoutCommentSize; i >= 0; i -= 1) {\n      if (buffer.readUInt32LE(i) !== 0x06054b50) continue;\n      // found eocdr\n      var eocdrBuffer = buffer.slice(i);\n\n      // 0 - End of central directory signature = 0x06054b50\n      // 4 - Number of this disk\n      var diskNumber = eocdrBuffer.readUInt16LE(4);\n      if (diskNumber !== 0) return callback(new Error(\"multi-disk zip files are not supported: found disk number: \" + diskNumber));\n      // 6 - Disk where central directory starts\n      // 8 - Number of central directory records on this disk\n      // 10 - Total number of central directory records\n      var entryCount = eocdrBuffer.readUInt16LE(10);\n      // 12 - Size of central directory (bytes)\n      // 16 - Offset of start of central directory, relative to start of archive\n      var centralDirectoryOffset = eocdrBuffer.readUInt32LE(16);\n      // 20 - Comment length\n      var commentLength = eocdrBuffer.readUInt16LE(20);\n      var expectedCommentLength = eocdrBuffer.length - eocdrWithoutCommentSize;\n      if (commentLength !== expectedCommentLength) {\n        return callback(new Error(\"invalid comment length. expected: \" + expectedCommentLength + \". found: \" + commentLength));\n      }\n      // 22 - Comment\n      // the encoding is always cp437.\n      var comment = bufferToString(eocdrBuffer, 22, eocdrBuffer.length, false);\n\n      if (!(entryCount === 0xffff || centralDirectoryOffset === 0xffffffff)) {\n        return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries));\n      }\n\n      // ZIP64 format\n\n      // ZIP64 Zip64 end of central directory locator\n      var zip64EocdlBuffer = new Buffer(20);\n      var zip64EocdlOffset = bufferReadStart + i - zip64EocdlBuffer.length;\n      readAndAssertNoEof(reader, zip64EocdlBuffer, 0, zip64EocdlBuffer.length, zip64EocdlOffset, function(err) {\n        if (err) return callback(err);\n\n        // 0 - zip64 end of central dir locator signature = 0x07064b50\n        if (zip64EocdlBuffer.readUInt32LE(0) !== 0x07064b50) {\n          return callback(new Error(\"invalid ZIP64 End of Central Directory Locator signature\"));\n        }\n        // 4 - number of the disk with the start of the zip64 end of central directory\n        // 8 - relative offset of the zip64 end of central directory record\n        var zip64EocdrOffset = readUInt64LE(zip64EocdlBuffer, 8);\n        // 16 - total number of disks\n\n        // ZIP64 end of central directory record\n        var zip64EocdrBuffer = new Buffer(56);\n        readAndAssertNoEof(reader, zip64EocdrBuffer, 0, zip64EocdrBuffer.length, zip64EocdrOffset, function(err) {\n          if (err) return callback(err);\n\n          // 0 - zip64 end of central dir signature                           4 bytes  (0x06064b50)\n          if (zip64EocdrBuffer.readUInt32LE(0) !== 0x06064b50) return callback(new Error(\"invalid ZIP64 end of central directory record signature\"));\n          // 4 - size of zip64 end of central directory record                8 bytes\n          // 12 - version made by                                             2 bytes\n          // 14 - version needed to extract                                   2 bytes\n          // 16 - number of this disk                                         4 bytes\n          // 20 - number of the disk with the start of the central directory  4 bytes\n          // 24 - total number of entries in the central directory on this disk         8 bytes\n          // 32 - total number of entries in the central directory            8 bytes\n          entryCount = readUInt64LE(zip64EocdrBuffer, 32);\n          // 40 - size of the central directory                               8 bytes\n          // 48 - offset of start of central directory with respect to the starting disk number     8 bytes\n          centralDirectoryOffset = readUInt64LE(zip64EocdrBuffer, 48);\n          // 56 - zip64 extensible data sector                                (variable size)\n          return callback(null, new ZipFile(reader, centralDirectoryOffset, totalSize, entryCount, comment, options.autoClose, options.lazyEntries));\n        });\n      });\n      return;\n    }\n    callback(new Error(\"end of central directory record signature not found\"));\n  });\n}\n\nutil.inherits(ZipFile, EventEmitter);\nfunction ZipFile(reader, centralDirectoryOffset, fileSize, entryCount, comment, autoClose, lazyEntries) {\n  var self = this;\n  EventEmitter.call(self);\n  self.reader = reader;\n  // forward close events\n  self.reader.on(\"error\", function(err) {\n    // error closing the fd\n    emitError(self, err);\n  });\n  self.reader.once(\"close\", function() {\n    self.emit(\"close\");\n  });\n  self.readEntryCursor = centralDirectoryOffset;\n  self.fileSize = fileSize;\n  self.entryCount = entryCount;\n  self.comment = comment;\n  self.entriesRead = 0;\n  self.autoClose = !!autoClose;\n  self.lazyEntries = !!lazyEntries;\n  self.isOpen = true;\n  self.emittedError = false;\n\n  if (!self.lazyEntries) self.readEntry();\n}\nZipFile.prototype.close = function() {\n  if (!this.isOpen) return;\n  this.isOpen = false;\n  this.reader.unref();\n};\n\nfunction emitErrorAndAutoClose(self, err) {\n  if (self.autoClose) self.close();\n  emitError(self, err);\n}\nfunction emitError(self, err) {\n  if (self.emittedError) return;\n  self.emittedError = true;\n  self.emit(\"error\", err);\n}\n\nZipFile.prototype.readEntry = function() {\n  var self = this;\n  if (self.entryCount === self.entriesRead) {\n    // done with metadata\n    setImmediate(function() {\n      if (self.autoClose) self.close();\n      if (self.emittedError) return;\n      self.emit(\"end\");\n    });\n    return;\n  }\n  if (self.emittedError) return;\n  var buffer = new Buffer(46);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {\n    if (err) return emitErrorAndAutoClose(self, err);\n    if (self.emittedError) return;\n    var entry = new Entry();\n    // 0 - Central directory file header signature\n    var signature = buffer.readUInt32LE(0);\n    if (signature !== 0x02014b50) return emitErrorAndAutoClose(self, new Error(\"invalid central directory file header signature: 0x\" + signature.toString(16)));\n    // 4 - Version made by\n    entry.versionMadeBy = buffer.readUInt16LE(4);\n    // 6 - Version needed to extract (minimum)\n    entry.versionNeededToExtract = buffer.readUInt16LE(6);\n    // 8 - General purpose bit flag\n    entry.generalPurposeBitFlag = buffer.readUInt16LE(8);\n    // 10 - Compression method\n    entry.compressionMethod = buffer.readUInt16LE(10);\n    // 12 - File last modification time\n    entry.lastModFileTime = buffer.readUInt16LE(12);\n    // 14 - File last modification date\n    entry.lastModFileDate = buffer.readUInt16LE(14);\n    // 16 - CRC-32\n    entry.crc32 = buffer.readUInt32LE(16);\n    // 20 - Compressed size\n    entry.compressedSize = buffer.readUInt32LE(20);\n    // 24 - Uncompressed size\n    entry.uncompressedSize = buffer.readUInt32LE(24);\n    // 28 - File name length (n)\n    entry.fileNameLength = buffer.readUInt16LE(28);\n    // 30 - Extra field length (m)\n    entry.extraFieldLength = buffer.readUInt16LE(30);\n    // 32 - File comment length (k)\n    entry.fileCommentLength = buffer.readUInt16LE(32);\n    // 34 - Disk number where file starts\n    // 36 - Internal file attributes\n    entry.internalFileAttributes = buffer.readUInt16LE(36);\n    // 38 - External file attributes\n    entry.externalFileAttributes = buffer.readUInt32LE(38);\n    // 42 - Relative offset of local file header\n    entry.relativeOffsetOfLocalHeader = buffer.readUInt32LE(42);\n\n    self.readEntryCursor += 46;\n\n    buffer = new Buffer(entry.fileNameLength + entry.extraFieldLength + entry.fileCommentLength);\n    readAndAssertNoEof(self.reader, buffer, 0, buffer.length, self.readEntryCursor, function(err) {\n      if (err) return emitErrorAndAutoClose(self, err);\n      if (self.emittedError) return;\n      // 46 - File name\n      var isUtf8 = entry.generalPurposeBitFlag & 0x800\n      try {\n        entry.fileName = bufferToString(buffer, 0, entry.fileNameLength, isUtf8);\n      } catch (e) {\n        return emitErrorAndAutoClose(self, e);\n      }\n\n      // 46+n - Extra field\n      var fileCommentStart = entry.fileNameLength + entry.extraFieldLength;\n      var extraFieldBuffer = buffer.slice(entry.fileNameLength, fileCommentStart);\n      entry.extraFields = [];\n      var i = 0;\n      while (i < extraFieldBuffer.length) {\n        var headerId = extraFieldBuffer.readUInt16LE(i + 0);\n        var dataSize = extraFieldBuffer.readUInt16LE(i + 2);\n        var dataStart = i + 4;\n        var dataEnd = dataStart + dataSize;\n        var dataBuffer = new Buffer(dataSize);\n        extraFieldBuffer.copy(dataBuffer, 0, dataStart, dataEnd);\n        entry.extraFields.push({\n          id: headerId,\n          data: dataBuffer,\n        });\n        i = dataEnd;\n      }\n\n      // 46+n+m - File comment\n      try {\n        entry.fileComment = bufferToString(buffer, fileCommentStart, fileCommentStart + entry.fileCommentLength, isUtf8);\n      } catch (e) {\n        return emitErrorAndAutoClose(self, e);\n      }\n\n      self.readEntryCursor += buffer.length;\n      self.entriesRead += 1;\n\n      if (entry.uncompressedSize            === 0xffffffff ||\n          entry.compressedSize              === 0xffffffff ||\n          entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n        // ZIP64 format\n        // find the Zip64 Extended Information Extra Field\n        var zip64EiefBuffer = null;\n        for (var i = 0; i < entry.extraFields.length; i++) {\n          var extraField = entry.extraFields[i];\n          if (extraField.id === 0x0001) {\n            zip64EiefBuffer = extraField.data;\n            break;\n          }\n        }\n        if (zip64EiefBuffer == null) return emitErrorAndAutoClose(self, new Error(\"expected Zip64 Extended Information Extra Field\"));\n        var index = 0;\n        // 0 - Original Size          8 bytes\n        if (entry.uncompressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) return emitErrorAndAutoClose(self, new Error(\"Zip64 Extended Information Extra Field does not include Original Size\"));\n          entry.uncompressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 8 - Compressed Size        8 bytes\n        if (entry.compressedSize === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) return emitErrorAndAutoClose(self, new Error(\"Zip64 Extended Information Extra Field does not include Compressed Size\"));\n          entry.compressedSize = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 16 - Relative Header Offset 8 bytes\n        if (entry.relativeOffsetOfLocalHeader === 0xffffffff) {\n          if (index + 8 > zip64EiefBuffer.length) return emitErrorAndAutoClose(self, new Error(\"Zip64 Extended Information Extra Field does not include Relative Header Offset\"));\n          entry.relativeOffsetOfLocalHeader = readUInt64LE(zip64EiefBuffer, index);\n          index += 8;\n        }\n        // 24 - Disk Start Number      4 bytes\n      }\n\n      // validate file size\n      if (entry.compressionMethod === 0) {\n        if (entry.compressedSize !== entry.uncompressedSize) {\n          var msg = \"compressed/uncompressed size mismatch for stored file: \" + entry.compressedSize + \" != \" + entry.uncompressedSize;\n          return emitErrorAndAutoClose(self, new Error(msg));\n        }\n      }\n\n      // validate file name\n      if (entry.fileName.indexOf(\"\\\\\") !== -1) return emitErrorAndAutoClose(self, new Error(\"invalid characters in fileName: \" + entry.fileName));\n      if (/^[a-zA-Z]:/.test(entry.fileName) || /^\\//.test(entry.fileName)) return emitErrorAndAutoClose(self, new Error(\"absolute path: \" + entry.fileName));\n      if (entry.fileName.split(\"/\").indexOf(\"..\") !== -1) return emitErrorAndAutoClose(self, new Error(\"invalid relative path: \" + entry.fileName));\n      self.emit(\"entry\", entry);\n\n      if (!self.lazyEntries) self.readEntry();\n    });\n  });\n};\n\nZipFile.prototype.openReadStream = function(entry, callback) {\n  var self = this;\n  if (!self.isOpen) return callback(new Error(\"closed\"));\n  // make sure we don't lose the fd before we open the actual read stream\n  self.reader.ref();\n  var buffer = new Buffer(30);\n  readAndAssertNoEof(self.reader, buffer, 0, buffer.length, entry.relativeOffsetOfLocalHeader, function(err) {\n    try {\n      if (err) return callback(err);\n      // 0 - Local file header signature = 0x04034b50\n      var signature = buffer.readUInt32LE(0);\n      if (signature !== 0x04034b50) return callback(new Error(\"invalid local file header signature: 0x\" + signature.toString(16)));\n      // all this should be redundant\n      // 4 - Version needed to extract (minimum)\n      // 6 - General purpose bit flag\n      // 8 - Compression method\n      // 10 - File last modification time\n      // 12 - File last modification date\n      // 14 - CRC-32\n      // 18 - Compressed size\n      // 22 - Uncompressed size\n      // 26 - File name length (n)\n      var fileNameLength = buffer.readUInt16LE(26);\n      // 28 - Extra field length (m)\n      var extraFieldLength = buffer.readUInt16LE(28);\n      // 30 - File name\n      // 30+n - Extra field\n      var localFileHeaderEnd = entry.relativeOffsetOfLocalHeader + buffer.length + fileNameLength + extraFieldLength;\n      var compressed;\n      if (entry.compressionMethod === 0) {\n        // 0 - The file is stored (no compression)\n        compressed = false;\n      } else if (entry.compressionMethod === 8) {\n        // 8 - The file is Deflated\n        compressed = true;\n      } else {\n        return callback(new Error(\"unsupported compression method: \" + entry.compressionMethod));\n      }\n      var fileDataStart = localFileHeaderEnd;\n      var fileDataEnd = fileDataStart + entry.compressedSize;\n      if (entry.compressedSize !== 0) {\n        // bounds check now, because the read streams will probably not complain loud enough.\n        // since we're dealing with an unsigned offset plus an unsigned size,\n        // we only have 1 thing to check for.\n        if (fileDataEnd > self.fileSize) {\n          return callback(new Error(\"file data overflows file bounds: \" +\n              fileDataStart + \" + \" + entry.compressedSize + \" > \" + self.fileSize));\n        }\n      }\n      var readStream = self.reader.createReadStream({start: fileDataStart, end: fileDataEnd});\n      var endpointStream = readStream;\n      if (compressed) {\n        var destroyed = false;\n        var inflateFilter = zlib.createInflateRaw();\n        readStream.on(\"error\", function(err) {\n          // setImmediate here because errors can be emitted during the first call to pipe()\n          setImmediate(function() {\n            if (!destroyed) inflateFilter.emit(\"error\", err);\n          });\n        });\n\n        var checkerStream = new AssertByteCountStream(entry.uncompressedSize);\n        inflateFilter.on(\"error\", function(err) {\n          // forward zlib errors to the client-visible stream\n          setImmediate(function() {\n            if (!destroyed) checkerStream.emit(\"error\", err);\n          });\n        });\n        checkerStream.destroy = function() {\n          destroyed = true;\n          inflateFilter.unpipe(checkerStream);\n          readStream.unpipe(inflateFilter);\n          // TODO: the inflateFilter now causes a memory leak. see Issue #27.\n          readStream.destroy();\n        };\n        endpointStream = readStream.pipe(inflateFilter).pipe(checkerStream);\n      }\n      callback(null, endpointStream);\n    } finally {\n      self.reader.unref();\n    }\n  });\n};\n\nfunction Entry() {\n}\nEntry.prototype.getLastModDate = function() {\n  return dosDateTimeToDate(this.lastModFileDate, this.lastModFileTime);\n};\n\nfunction dosDateTimeToDate(date, time) {\n  var day = date & 0x1f; // 1-31\n  var month = (date >> 5 & 0xf) - 1; // 1-12, 0-11\n  var year = (date >> 9 & 0x7f) + 1980; // 0-128, 1980-2108\n\n  var millisecond = 0;\n  var second = (time & 0x1f) * 2; // 0-29, 0-58 (even numbers)\n  var minute = time >> 5 & 0x3f; // 0-59\n  var hour = time >> 11 & 0x1f; // 0-23\n\n  return new Date(year, month, day, hour, minute, second, millisecond);\n}\n\nfunction readAndAssertNoEof(reader, buffer, offset, length, position, callback) {\n  if (length === 0) {\n    // fs.read will throw an out-of-bounds error if you try to read 0 bytes from a 0 byte file\n    return setImmediate(function() { callback(null, new Buffer(0)); });\n  }\n  reader.read(buffer, offset, length, position, function(err, bytesRead) {\n    if (err) return callback(err);\n    if (bytesRead < length) return callback(new Error(\"unexpected EOF\"));\n    callback();\n  });\n}\n\nutil.inherits(AssertByteCountStream, Transform);\nfunction AssertByteCountStream(byteCount) {\n  Transform.call(this);\n  this.actualByteCount = 0;\n  this.expectedByteCount = byteCount;\n}\nAssertByteCountStream.prototype._transform = function(chunk, encoding, cb) {\n  this.actualByteCount += chunk.length;\n  if (this.actualByteCount > this.expectedByteCount) {\n    var msg = \"too many bytes in the stream. expected \" + this.expectedByteCount + \". got at least \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n  cb(null, chunk);\n};\nAssertByteCountStream.prototype._flush = function(cb) {\n  if (this.actualByteCount < this.expectedByteCount) {\n    var msg = \"not enough bytes in the stream. expected \" + this.expectedByteCount + \". got only \" + this.actualByteCount;\n    return cb(new Error(msg));\n  }\n  cb();\n};\n\nutil.inherits(RandomAccessReader, EventEmitter);\nfunction RandomAccessReader() {\n  EventEmitter.call(this);\n  this.refCount = 0;\n}\nRandomAccessReader.prototype.ref = function() {\n  this.refCount += 1;\n};\nRandomAccessReader.prototype.unref = function() {\n  var self = this;\n  self.refCount -= 1;\n\n  if (self.refCount > 0) return;\n  if (self.refCount < 0) throw new Error(\"invalid unref\");\n\n  self.close(onCloseDone);\n\n  function onCloseDone(err) {\n    if (err) return self.emit('error', err);\n    self.emit('close');\n  }\n};\nRandomAccessReader.prototype.createReadStream = function(options) {\n  var start = options.start;\n  var end = options.end;\n  if (start === end) {\n    var emptyStream = new PassThrough();\n    setImmediate(function() {\n      emptyStream.end();\n    });\n    return emptyStream;\n  }\n  var stream = this._readStreamForRange(start, end);\n\n  var destroyed = false;\n  var refUnrefFilter = new RefUnrefFilter(this);\n  stream.on(\"error\", function(err) {\n    setImmediate(function() {\n      if (!destroyed) refUnrefFilter.emit(\"error\", err);\n    });\n  });\n  refUnrefFilter.destroy = function() {\n    stream.unpipe(refUnrefFilter);\n    refUnrefFilter.unref();\n    stream.destroy();\n  };\n\n  var byteCounter = new AssertByteCountStream(end - start);\n  refUnrefFilter.on(\"error\", function(err) {\n    setImmediate(function() {\n      if (!destroyed) byteCounter.emit(\"error\", err);\n    });\n  });\n  byteCounter.destroy = function() {\n    destroyed = true;\n    refUnrefFilter.unpipe(byteCounter);\n    refUnrefFilter.destroy();\n  };\n\n  return stream.pipe(refUnrefFilter).pipe(byteCounter);\n};\nRandomAccessReader.prototype._readStreamForRange = function(start, end) {\n  throw new Error(\"not implemented\");\n};\nRandomAccessReader.prototype.read = function(buffer, offset, length, position, callback) {\n  var readStream = this.createReadStream({start: position, end: position + length});\n  var writeStream = new Writable();\n  var written = 0;\n  writeStream._write = function(chunk, encoding, cb) {\n    chunk.copy(buffer, offset + written, 0, chunk.length);\n    written += chunk.length;\n    cb();\n  };\n  writeStream.on(\"finish\", callback);\n  readStream.on(\"error\", function(error) {\n    callback(error);\n  });\n  readStream.pipe(writeStream);\n};\nRandomAccessReader.prototype.close = function(callback) {\n  setImmediate(callback);\n};\n\nutil.inherits(RefUnrefFilter, PassThrough);\nfunction RefUnrefFilter(context) {\n  PassThrough.call(this);\n  this.context = context;\n  this.context.ref();\n  this.unreffedYet = false;\n}\nRefUnrefFilter.prototype._flush = function(cb) {\n  this.unref();\n  cb();\n};\nRefUnrefFilter.prototype.unref = function(cb) {\n  if (this.unreffedYet) return;\n  this.unreffedYet = true;\n  this.context.unref();\n};\n\nvar cp437 = '\\u0000 !\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~';\nfunction bufferToString(buffer, start, end, isUtf8) {\n  if (isUtf8) {\n    return buffer.toString(\"utf8\", start, end);\n  } else {\n    var result = \"\";\n    for (var i = start; i < end; i++) {\n      result += cp437[buffer[i]];\n    }\n    return result;\n  }\n}\n\nfunction readUInt64LE(buffer, offset) {\n  // there is no native function for this, because we can't actually store 64-bit integers precisely.\n  // after 53 bits, JavaScript's Number type (IEEE 754 double) can't store individual integers anymore.\n  // but since 53 bits is a whole lot more than 32 bits, we do our best anyway.\n  var lower32 = buffer.readUInt32LE(offset);\n  var upper32 = buffer.readUInt32LE(offset + 4);\n  // we can't use bitshifting here, because JavaScript bitshifting only works on 32-bit integers.\n  return upper32 * 0x100000000 + lower32;\n  // as long as we're bounds checking the result of this function against the total file size,\n  // we'll catch any overflow errors, because we already made sure the total file size was within reason.\n}\n\nfunction defaultCallback(err) {\n  if (err) throw err;\n}\n","import {DefaultResponse, Request} from \"../services/request\";\n\nexport interface Language {\n\tiso: string\n\tname: string\n\trtl: string\n}\n\nexport interface ProjectLanguage extends Language {\n\twords: string,\n\tis_default: string\n}\n\nexport interface SystemLanguagesResponse {\n\tlanguages: Language[],\n\tresponse: DefaultResponse\n}\n\nexport interface ProjectLanguagesList {\n\tlanguages: ProjectLanguage[],\n\tresponse: DefaultResponse\n}\n\nexport interface AddRemoveLanguagesParams {\n\tid: string,\n\tiso: string[]\n}\n\nexport interface SetLanguagesParams {\n\tid: string\n\toriginal_iso: string\n\tcustom_iso?: string\n\tcustom_name?: string\n}\n\nexport class Languages extends Request {\n\tconstructor(token: string) {\n\t\tsuper(token);\n\t}\n\n\tpublic async listSystemLanguages(): Promise<SystemLanguagesResponse> {\n\t\treturn await this.get<SystemLanguagesResponse, any>('language/listall');\n\t}\n\n\tpublic async list(id: string): Promise<ProjectLanguagesList> {\n\t\treturn await this.get<ProjectLanguagesList, any>('language/list', {\n\t\t\tid: id\n\t\t});\n\t}\n\n\tpublic async add(data: AddRemoveLanguagesParams): Promise<DefaultResponse> {\n\t\treturn await this.post<DefaultResponse, AddRemoveLanguagesParams>('language/add', data);\n\t}\n\n\tpublic async setProperties(data: SetLanguagesParams): Promise<DefaultResponse> {\n\t\treturn await this.post<DefaultResponse, SetLanguagesParams>('language/add', data);\n\t}\n\n\tpublic async remove(data: AddRemoveLanguagesParams): Promise<DefaultResponse> {\n\t\treturn await this.post<DefaultResponse, AddRemoveLanguagesParams>('language/remove', data);\n\t}\n}","import {DefaultResponse, LokaliseResponse, Request} from \"../services/request\";\nimport {FileFormat, PlaceholderFormat, PluralFormat} from \"../index\";\n\nconst extract = require('extract-zip')\nconst os = require('os');\nconst path = require('path');\nconst http = require('https');\nconst fs = require('fs');\n\nexport enum ExportEmpty {\n\tempty = \"empty\",\n\tbase = \"base\",\n\tskip = \"skip\"\n}\n\nexport enum ExportSort {\n\tfirst_added = \"first_added\",\n\tlast_added = \"last_added\",\n\tlast_updated = \"last_updated\",\n\ta_z = \"a_z\",\n\tz_a = \"z_a\"\n}\n\nexport enum JavaPropertiesEncoding {\n\tutf8 = \"utf-8\",\n\tlatin1 = \"latin-1\"\n}\n\nexport interface ProjectsListObject {\n\tid: string\n\tname: string\n\tdesc: string\n\tcreated: string,\n\towner: string\n}\n\nexport interface ProjectsList {\n\tprojects: ProjectsListObject[],\n\tresponse: LokaliseResponse\n}\n\nexport interface AddProjectParams {\n\tname: string,\n\tdescription?: string,\n\tbase_lang?: string\n}\n\nexport interface AddProjectResponse {\n\tproject: {\n\t\tid: number\n\t},\n\tresponse: LokaliseResponse\n}\n\nexport interface ExportProjectParams {\n\tid: number\n\ttype: FileFormat\n\tlangs?: string[]\n\tuse_original?: 0 | 1\n\tfilter?: any\n\tbundle_structure?: string\n\tdirectory_prefix?: string\n\twebhook_url?: string\n\texport_all?: 0 | 1\n\texport_empty?: ExportEmpty\n\tinclude_comments?: 0 | 1\n\tinclude_pids?: string[]\n\tinclude_tags?: string[]\n\texport_sort?: ExportSort\n\treplace_breaks?: 0 | 1\n\tyaml_include_root?: 0 | 1\n\tjson_unescaped_slashes?: 0 | 1\n\tjava_properties_encoding?: JavaPropertiesEncoding\n\tjava_properties_separator?: \"=\" | \":\"\n\tno_language_folders?: 0 | 1\n\ttriggers?: any\n\tplural_format?: PluralFormat\n\ticu_numeric?: 0 | 1\n\tplaceholder_format?: PlaceholderFormat\n}\n\nexport interface ExportResponse {\n\tbundle: {\n\t\tfile: string,\n\t\tfull_file: string\n\t},\n\tresponse: LokaliseResponse\n}\n\nexport interface ImportData {\n\tid: string\n\tfile: any\n\tlang_iso: string\n\treplace?: 0 | 1\n\tconvert_placeholders?: 0 | 1\n\ticu_plurals?: 0 | 1\n\tfill_empty?: 0 | 1\n\tdistinguish?: 0 | 1\n\tuse_trans_mem?: 0 | 1\n\thidden?: 0 | 1\n\ttags?: string[]\n\tfilename?: string\n\treplace_breaks?: 0 | 1\n}\n\nexport interface ProjectImportResponse {\n\tresult: {\n\t\tskipped: number,\n\t\tinserted: number,\n\t\tupdated: number\n\t},\n\tresponse: LokaliseResponse\n}\n\nexport interface UploadScreenshot {\n\tid: string,\n\tscreenshot: string,\n\tautotag: 0 | 1,\n\tkey_ids: string[]\n}\n\nexport class Projects extends Request {\n\tconstructor(token: string) {\n\t\tsuper(token);\n\t}\n\n\tpublic async list(): Promise<ProjectsList> {\n\t\treturn await this.get<ProjectsList, any>('project/list');\n\t}\n\n\tpublic async add(data: AddProjectParams): Promise<AddProjectResponse> {\n\t\treturn await this.post<AddProjectResponse, AddProjectParams>('project/add', data);\n\t}\n\n\tpublic async remove(id: string): Promise<DefaultResponse> {\n\t\treturn await this.post<DefaultResponse, any>('project/remove', {id: id});\n\t}\n\n\tpublic async import(data: ImportData): Promise<ProjectImportResponse> {\n\t\tdata.file = fs.createReadStream(path.resolve(data.file));\n\n\t\treturn await this.post<ProjectImportResponse, ImportData>('project/import', data);\n\t}\n\n\tpublic async export(data: ExportProjectParams): Promise<ExportResponse> {\n\t\treturn await this.post<ExportResponse, ExportProjectParams>('project/export', data);\n\t}\n\n\tpublic async uploadScreenShot(data: UploadScreenshot): Promise<DefaultResponse> {\n\t\treturn await this.post<DefaultResponse, UploadScreenshot>('project/screenshot', data);\n\t}\n\n\tpublic async createSnapshot(id: string, title: string): Promise<DefaultResponse> {\n\t\treturn await this.post<DefaultResponse, any>('project/export', {\n\t\t\tid: id,\n\t\t\ttitle: title\n\t\t});\n\t}\n\n\tpublic async empty(id: string): Promise<DefaultResponse> {\n\t\treturn await this.post<DefaultResponse, any>('project/export', {\n\t\t\tid: id\n\t\t});\n\t}\n\n\tpublic async exportToPath(filesPath: string, data: ExportProjectParams): Promise<ExportResponse> {\n\t\tlet tmpDir = os.tmpdir();\n\t\tlet exportData: ExportResponse = await this.export(data);\n\n\t\treturn new Promise<ExportResponse>((resolve: Function, reject: Function) => {\n\t\t\tif (exportData.response.code === \"200\") {\n\t\t\t\tconst tempFilePath = path.resolve(tmpDir, data.id + \".zip\");\n\t\t\t\tconst file = fs.createWriteStream(tempFilePath);\n\n\t\t\t\thttp.get(exportData.bundle.full_file, (res: any) => {\n\t\t\t\t\tres.pipe(file);\n\n\t\t\t\t\tres.on('end', () => {\n\t\t\t\t\t\textract(tempFilePath, {dir: path.resolve(filesPath)}, function (err: any) {\n\t\t\t\t\t\t\tresolve(exportData);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tconsole.error(\"Export error: \" + exportData.response.code + \" - \" + exportData.response.message);\n\t\t\t\treject(exportData.response);\n\t\t\t}\n\t\t})\n\t}\n}","import {DefaultResponse, LokaliseResponse, Request} from \"../services/request\";\nimport {PlaceholderFormat, PlatformBitMask, PluralFormat} from \"../index\";\n\nexport interface LocaleKey {\n\tkey: string\n\tplatform_mask: PlatformBitMask\n\tcontext: string\n\ttranslation: string\n\tplural_key: string\n\tis_hidden: string\n\tcreated_at: string\n\ttags?: string[]\n\tmodified_at: string\n\tfuzzy: string\n\tis_archived: string\n}\n\nexport interface LocaleKeyAppend extends LocaleKey {\n\tfilename_web: string,\n\thidden: number,\n\ttranslations: { [locale: string]: string },\n\tplural: string\n}\n\nexport interface StringsList {\n\tstrings: { [lang: string]: LocaleKey[] }\n\tresponse: LokaliseResponse\n}\n\nexport interface StringsListParams {\n\tid: string\n\tlangs?: object[]\n\tplatform_mask?: PlatformBitMask\n\tkeys?: object[]\n\ttags?: object[]\n\tplural_format?: PluralFormat\n\ticu_numeric?: boolean\n\tplaceholder_format?: PlaceholderFormat\n}\n\nexport interface AddKeysParams {\n\tid: number,\n\tdata: LocaleKeyAppend[]\n}\n\nexport interface AddKeysResponse {\n\tresult: {\n\t\tinserted: string,\n\t\tupdated: string\n\t},\n\tresponse: LokaliseResponse\n}\n\nexport interface RemoveKeysParams {\n\tid: number,\n\tkeys: string[]\n}\n\nexport class Strings extends Request {\n\tconstructor(token: string) {\n\t\tsuper(token);\n\t}\n\n\tpublic async list(params: StringsListParams): Promise<StringsList> {\n\t\treturn await this.post<StringsList, StringsListParams>('string/list/', params);\n\t}\n\n\tpublic async add(params: AddKeysParams): Promise<AddKeysResponse> {\n\t\treturn await this.post<AddKeysResponse, AddKeysParams>('string/set', params);\n\t}\n\n\tpublic async remove(params: RemoveKeysParams): Promise<DefaultResponse> {\n\t\treturn await this.post<DefaultResponse, RemoveKeysParams>('string/list/', params);\n\t}\n}","import {Projects} from \"./api/projects\";\nimport {Strings} from \"./api/strings\";\nimport {Languages} from \"./api/languages\";\n\nexport enum PluralFormat {\n\tgeneric = \"generic\",\n\tjson_string = \"json_string\",\n\ticu = \"icu\",\n\tarray = \"array\",\n\ti18next = \"i18next\",\n\tsymfony = \"symfony\",\n}\n\nexport enum PlaceholderFormat {\n\tprintf = \"printf\",\n\tios = \"ios\",\n\ticu = \"icu\",\n\tnet = \"net\",\n\tsymfony = \"symfony\"\n}\n\nexport enum FileFormat {\n\tandroid_sdk = \"android_sdk\",\n\tios_sdk = \"ios_sdk\",\n\txml = \"xml\",\n\tstrings = \"strings\",\n\tcsv = \"csv\",\n\txlsx = \"xlsx\",\n\tpo = \"po\",\n\tproperties = \"properties\",\n\tjson = \"json\",\n\txliff = \"xliff\",\n\tplist = \"plist\",\n\tresx = \"resx\",\n\tjs = \"js\",\n\treact_native = \"react_native\",\n\tsymfony_xliff = \"symfony_xliff\",\n\txlf = \"xlf\",\n\tphp = \"php\",\n\tini = \"ini\",\n\truby_yaml = \"ruby_yaml\",\n\tyaml = \"yaml\",\n\tstf = \"stf\",\n\tts = \"ts\"\n}\n\nexport enum PlatformBitMask {\n\tIOS = 1,\n\tAndroid = 2,\n\tWeb = 4,\n\tOther = 16\n}\n\nexport class LokaliseAPI {\n\tpublic projects: Projects;\n\tpublic strings: Strings;\n\tpublic languages: Languages;\n\n\tconstructor(token: string) {\n\t\tthis.projects = new Projects(token);\n\t\tthis.languages = new Languages(token);\n\t\tthis.strings = new Strings(token);\n\t}\n}\n","import * as superagent from 'superagent';\n\nconst request = require('request');\nconst LOKALISE_API_URL = 'https://api.lokalise.co/api/';\n\nexport interface LokaliseResponse {\n\tstatus: string,\n\tcode: string,\n\tmessage: string\n}\n\nexport interface DefaultResponse {\n\tresponse: LokaliseResponse\n}\n\nexport class Request {\n\tconstructor(readonly token: string) {\n\t}\n\n\tprotected get<T, U>(url: string, data?: U): Promise<T> {\n\t\treturn new Promise<T>((resolve: Function, reject: Function) => {\n\t\t\tsuperagent.get(LOKALISE_API_URL + url)\n\t\t\t\t.query({...{api_token: this.token}, ...data as {}})\n\t\t\t\t.end((err, res) => {\n\t\t\t\t\tif (!err) {\n\t\t\t\t\t\tresolve(res.body);\n\t\t\t\t\t} else {\n\t\t\t\t\t\treject(res);\n\t\t\t\t\t}\n\t\t\t\t})\n\t\t});\n\t}\n\n\tprotected post<T, U>(url: string, data?: U): Promise<T> {\n\t\tdata = this.arrayPropsToJson<U>(data);\n\n\t\treturn new Promise<T>((resolve: Function, reject: Function) => {\n\t\t\trequest.post({\n\t\t\t\turl: LOKALISE_API_URL + url,\n\t\t\t\tformData: {...{api_token: this.token}, ...data as {}}\n\t\t\t}, (err: any, res: any, body: any) => {\n\t\t\t\tif (!err) {\n\t\t\t\t\tresolve(JSON.parse(body));\n\t\t\t\t} else {\n\t\t\t\t\treject(res);\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t}\n\n\tprotected arrayPropsToJson<T extends { [key: string]: any }>(data: T): T {\n\t\tfor (let key in data) {\n\t\t\tif (\n\t\t\t\tkey === 'langs' ||\n\t\t\t\tkey === 'filter' ||\n\t\t\t\tkey === 'include_pids' ||\n\t\t\t\tkey === 'include_tags' ||\n\t\t\t\tkey === 'exclude_tags' ||\n\t\t\t\tkey === 'tags' ||\n\t\t\t\tkey === 'key_ids' ||\n\t\t\t\tkey === 'iso' ||\n\t\t\t\tkey === 'keys' ||\n\t\t\t\tkey === 'data'\n\t\t\t) {\n\t\t\t\tdata[key] = JSON.stringify(data[key])\n\t\t\t}\n\t\t}\n\n\t\treturn data;\n\t}\n}","module.exports = require(\"concat-stream\");","module.exports = require(\"debug\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"https\");","module.exports = require(\"mkdirp\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"request\");","module.exports = require(\"stream\");","module.exports = require(\"superagent\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");"],"sourceRoot":""}